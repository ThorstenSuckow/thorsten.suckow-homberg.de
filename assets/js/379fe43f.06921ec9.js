"use strict";(self.webpackChunkthorsten_suckow_homberg_de=self.webpackChunkthorsten_suckow_homberg_de||[]).push([[9500],{2417:e=>{e.exports=JSON.parse('{"permalink":"/blog/2022/04/15/extjs-simlets-and-omitting-the-status-code","editUrl":"https://github.com/thorstensuckow/thorsten.suckow-homberg.de/tree/main/blog/2022-04-15-extjs-simlets-and-omitting-the-status-code/index.md","source":"@site/blog/2022-04-15-extjs-simlets-and-omitting-the-status-code/index.md","title":"Fix: Ext JS Simlets and omitting the status code","description":"Fix: Ext JS Simlets and omitting the status code","date":"2022-04-15T00:00:00.000Z","tags":[{"inline":true,"label":"javascript","permalink":"/blog/tags/javascript"},{"inline":true,"label":"sencha","permalink":"/blog/tags/sencha"},{"inline":true,"label":"extjs","permalink":"/blog/tags/extjs"}],"readingTime":2.505,"hasTruncateMarker":false,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Fix: Ext JS Simlets and omitting the status code","authors":["thorstensuckow"],"tags":["javascript","sencha","extjs"],"enableComments":true},"unlisted":false,"prevItem":{"title":"Releasing conjoon 1.0.0-beta.0","permalink":"/blog/2022/06/07/releasing-conjoon-1-0-0-beta"}}')},3279:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>c});var n=s(2417),o=s(4848),a=s(8453);const r={title:"Fix: Ext JS Simlets and omitting the status code",authors:["thorstensuckow"],tags:["javascript","sencha","extjs"],enableComments:!0},i=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Fix: Ext JS Simlets and omitting the status code",id:"fix-ext-js-simlets-and-omitting-the-status-code",level:2},{value:"The issue",id:"the-issue",level:3},{value:"The fix",id:"the-fix",level:3}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"fix-ext-js-simlets-and-omitting-the-status-code",children:"Fix: Ext JS Simlets and omitting the status code"}),"\n",(0,o.jsx)(t.p,{children:"I recently stumbled upon a mean error that was hard to track down. Luckily, the issue was caused by a simple carelessness regarding fully configured response-objects of Simlets used in the dev-environment of the conjoon-project and did not require any large refactoring."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.em,{children:["The original issue is tracked here: ",(0,o.jsx)(t.a,{href:"https://github.com/conjoon/extjs-app-webmail/issues/196",children:"https://github.com/conjoon/extjs-app-webmail/issues/196"})]})}),"\n",(0,o.jsx)(t.h3,{id:"the-issue",children:"The issue"}),"\n",(0,o.jsx)(t.p,{children:"The problem was related to batch-operations in Ext JS: When any operation of the batch fails, the pauseonexception-setting is considered and further processing of any remaining operation is halted. The user then has the option to retry the last failed operation, continuing with the remaining operations if this was finally successful.\nHowever, retrying some of the failed operations gave the following error:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:"https://cdn-images-1.medium.com/max/2000/0*_Lq8JlNRBBEutuGY.png",alt:""})}),"\n",(0,o.jsx)(t.p,{children:"The operation that failed \u2014 and which is now about to be retried \u2014 was already destroyed by Ext JS internal garbage-collector."}),"\n",(0,o.jsx)(t.h3,{id:"the-fix",children:"The fix"}),"\n",(0,o.jsx)(t.p,{children:"It took some time to find out that the operation was destroyed and that some of the properties required for re-running it were already de-referenced. This took me to the internals of response-handling of XMLHttpRequests of Ext JS and finally to the code where the HTTP status of a request was inspected. Take note that I\u2019m mainly developing with Simlets to avoid costly network roundtrips to any backend."}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"It is mandatory for the Simlets to properly treat mocked backend-errors by also providing the appropriate status-code."})}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"It was assumed that simply setting the success-property in any of the delete/put/...-methods of a simlet treating the request would later on be parsed internally; setting the status-code of the response automatically to anything other than 200. That is not the case. It is mandatory for the Simlets to properly treat mocked backend-errors by also providing the appropriate status-code."}),"\n",(0,o.jsxs)(t.p,{children:["The flaw was too often overseen since the status-field was ",(0,o.jsx)(t.strong,{children:"not set,"})," as the following code examples show (examples represent code in any of the delete/post/put/...-methods of a Json-Simlet; see Ext.ux.ajax.Simlet):"]}),"\n",(0,o.jsx)(t.p,{children:"The following leaves the ret.status-property undefined:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"    //....\n    const ret = {};\n    ret.responseText = Ext.JSON.encode({\n        success: false\n    });\n    return ret;\n"})}),"\n",(0,o.jsx)(t.p,{children:"\u2026 while the following re-uses the predefined value of 200 for the status, even if success=false should indicate that the request could not be processed as expected:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"    const \n        me = this,\n        ret = {};\n\n    Ext.Array.forEach(me.responseProps, function (prop) {\n        if (prop in me) {\n            ret[prop] = me[prop];\n        }\n    });\n\n    ret.responseText = Ext.JSON.encode({\n        success: false\n    });\n\n    return ret;\n"})}),"\n",(0,o.jsx)(t.p,{children:"In both cases, Ext.data.request.Ajax would parse the response and its status in the onComplete-method:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"    result = Ext.data.request.Ajax.parseStatus(xhr.status, xhr);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["An undefined status would cause the response to be treated as ",(0,o.jsx)(t.strong,{children:"not successful"})," (example 1), while anything other than undefined would be parsed and interpreted according to its HTTP-status representative (successful: 200; failure: 404, 500 etc.)."]}),"\n",(0,o.jsx)(t.p,{children:"ExtJS would assume that a successful operation is not needed anymore; it is automatically destroyed then. This was unexpected behavior in this case, since the code marked the operation as a failure, but not via the status-code, which was required."})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>i});var n=s(6540);const o={},a=n.createContext(o);function r(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);