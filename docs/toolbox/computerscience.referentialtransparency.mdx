---
title: "Referential Transparency"
---

import {BackButton} from "../../src/components/BackButton.js";
import {BibRef, GlosRef} from "../../src/components/References";

# Referential Transparency (Computer Science)

If an expression can be substituted for a value without changing the program's computational result, the expression is **referential transparent**.

The expression needs to be <GlosRef name="pure" file="cs.purefunction" /> in order to achieve **Referential Transparency**.

let $P$ be the **referential transparent context**, the _Program_, with $P\colon f \circ g$ with $f\colon Y \rightarrow Z$, $g\colon X \rightarrow Y$

if $\forall g(x) \in Y, y \in Y: f(g(x)) = f(y) \implies g(x) = y$, then $g$ is **referential transparent**.

> _"A mode of containment φ is referentially transparent if, whenever an occurrence of a singular term $t$ is purely referential in a term or sentence $ψ(t)$, it is purely referential also in the containing term or sentence $φ(ψ(t))$."_ [Quine: Word and Object, §30](https://archive.org/details/in.ernet.dli.2015.529086)

> _"By this, an operator is referentially transparent if it preserves applicability of Leibniz's law, or substitutivity of identity:
the principle that any subexpression can be replaced by any other equal in value. "_ [Sondergaard, Sestoft: Referential Transparency,
Definiteness and Unfoldability, pp. 11](https://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf)

## Example

For $x \in \N, y \in \N$:

```javascript

function f (y) {
    return y * y;
}

function g (x) {
    return x + 1;
}

// f(?) = 64
// 64 = 8 * 8; 64 = 8 * 8; 8 = 7 + 1; 8 = g (7); -> ? = 8 || g(7)
f(g(7)) === f (8);
```

<BackButton />

--------
see also
 - [Andrew Birkett: Referentially transparent](https://www.nobugs.org/blog/archives/2008/11/12/why-do-they-call-it-referentially-transparent/)