---
title: "Perspective Projection"
slug: "perspective-projection"
description: "Derivation of the lookAt view matrix in OpenGL, from linear algebra fundamentals to geometric interpretation of rotational and translational components."
tags: [computer graphics, linear algebra, opengl]
keywords: [lookAt matrix, OpenGL view matrix, coordinate systems, change of basis, camera transformation, graphics pipeline]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {BackButton} from "../../../src/components/BackButton.js";
import {Figure, BibRef, GlosRef, Wiki, Cite} from "../../../src/components/References";
import {Embed} from "../../../src/components/Embed";
import CodeBlock from '@theme/CodeBlock';

import camera_obscura from "./img/perspective-projection/camera_obscura.png";
import railroad_tracks from "./img/perspective-projection/railroad_tracks.png";

import ortho_proj_cube_iso from "./img/perspective-projection/ortho_proj_cube_iso_small.gif";
import ortho_proj_cube_ortho_front from "./img/perspective-projection/ortho_proj_cube_ortho_front_small.gif";
import ortho_proj_cube_persp_front from "./img/perspective-projection/ortho_proj_cube_persp_front_small.gif";

import unitcube from "./img/perspective-projection/unitcube.png";


import orthogonal_projection_code from '!!raw-loader!./plots/perspective-projection/orthogonal-projection.py?raw';

export const figures = {
    camera_obscura: 1,
    unitcube: 2,
    ortho_proj_cube_iso : 3,
    ortho_proj_cube_ortho_front : 4,
    ortho_proj_cube_persp_front : 5,
    railroad_tracks: 6
}

## Introduction

This article describes one of the final steps in the rendering pipeline: Projection and perspective transformations.

While in perspective projection all projection lines converge at a single point - producing the familiar sense of depth—in orthographic projection these lines run parallel to each other. With this projection type, parallel lines therefore remain parallel even after mapping onto the so-called unit cube.

We begin with the orthographic projection and derive a projection matrix that maps an arbitrary view volume onto the so-called unit cube. Along the way, we use figures and an interactive application to show how an orthographic projection affects objects we usually perceive in a perspective manner.

We then derive the perspective projection and show how choosing a near and a far viewing plane, as well as a height and a width, creates a so-called view frustum that contains the objects visible to the observer. All remaining objects in the world are ignored in the subsequent projection.

The article concludes by summarizing the OpenGL rendering pipeline and closing with a brief derivation of the transformation into normalized device coordinates (NDC) of the perspective projection.



## Projection Planes

In the final steps of the rendering pipeline, the _perspective divide_ converts clip-space coordinates to _normalized device coordinates_[^ndc]; the _viewport transform_ maps them to screen space, and _rasterization_ produces the 2D image.

[^ndc]: A common stumbling block when you’re used to absolute screen pixels: How are you supposed to scale anything when there’s "nothing" to scale against?

Before this happens, a view matrix $\boldsymbol{M}_\text{lookAt}$ is constructed that transforms world coordinates into camera coordinates, defined by a vantage point $\text{eye}_{xyz}$, the observed point  $c$ and a vector  $\vec{up}$  representing the camera’s up direction at camera at $\text{eye}_{xyz}$ looking at $c$.

Transforming world into camera coordinates isn’t particularly helpful on its own. In a scene graph with hundreds of nodes, we still have to decide which ones should actually appear on screen. Even if we know the viewer’s position and look direction, using a single point as render input yields an almost empty image. And approximating a point cloud with only the device’s height and width doesn’t suffice: it may hint at the aspect ratio, but it tells us nothing about scaling, depth range, or clipping.

In general, the camera implicit in computing camera coordinates is a pinhole camera - an idealized model with an infinitesimally small aperture that admits rays and produces an image. We push the abstraction a step further: in computer graphics we don’t capture photons, we trace geometric lines from the scene’s vertices through the pinhole onto a projection plane. If you like the _camera obscura_[^cameraobscura] picture: place a screen behind the pinhole and the projected points meet on that plane, yielding a mirrored, upside-down image (see <Figure idx={figures.camera_obscura} />).

[^cameraobscura]: see https://en.wikipedia.org/wiki/Camera_obscura, retrieved 20.08.2025

<Embed
    modeAware={false}
    figref={figures.camera_obscura}
    title={
        "First published picture of camera obscura in Gemma Frisius' 1545 book De Radio Astronomica et Geometrica. (Source: <a href='https://commons.wikimedia.org/wiki/File:1545_gemma_frisius_-_camera-obscura-sonnenfinsternis_1545-650x337.jpg'>Wikipedia</a>)"}>
    <img src={camera_obscura}  />
</Embed>

However, our projection plane is in front of us. In the following, we’ll determine its size, its distance from our position, and which scene objects fall into the resulting <Wiki name="view frustum" file="computergraphics.viewfrustum" />



## Excursus: View Space, Clip Space, the Canonical View Volume and NDCs
In the following, we will give a brief introduction to clipping, which is a process that that discards geometry that lies outside a view volume.
In short, primitives removed during clipping will not be part of the Canonical View Volume which contains all necessary geometry passed on to the final rasterization and on-screen display stages of the rendering pipeline.<br />
 Clipping is done by OpenGL with the help of the homogeneous coordinate component $w$. The following introduces the process with the help of orthographic projection, but it can be applied analogously with perspective projection, as we will see later.

In **camera space**, the six planes $l, r, b, t, n, f$ of a view volume $\boldsymbol{V}$ specify the _clipping planes_ (see <Figure idx={figures.unitcube} />). Roughly speaking, all vertices within the view volume $\boldsymbol{V}$ are considered to be preserved for rendering.

<Embed
    modeAware={true}
    figref={figures.unitcube}
    title={
        "Visualization of the unit cube U and a generic view volume V to be projected into U. The illustration shows the camera space of the scene. "}>
    <img src={unitcube}  />
</Embed>

After multiplying a vertex with the **projection matrix** which represents an orthographic or perspective projection, the homogenous coordinate

<center>
`gl_Position` = $(x, y, z, w)$
</center>

of a vertex shader is in **clip space**[^gl_Position].

[^gl_position]: see https://registry.khronos.org/OpenGL-Refpages/gl4/html/gl_Position.xhtml, retrieved 05.09.2025

OpenGL then performs clipping of the primitives against the inequalities

$$
-w \leq x \leq w \land
-w \leq y \leq w \land
-w \leq z \leq w
$$

<Cite name="KSS17" pp="Figure 5.2, 201" />[^inequalities]. Primitives outside clip space are discarded, while the visible portion of intersecting primitives is rasterized  <Cite name="SWH15" pp="2 96ff." />.

[^inequalities]: "Units normalized such that divide by w leaves visible points between -1.0 to +1.0" (_idb._). Additionally, _de Vries_ provides a good introduction into the coordinate systems used by OpenGL in <Cite name="Vri20" />

Once clipping has finished, the clip coordinates are mapped to Normalized Device Coordinates by the homogeneous divide

$$
(x_\text{ndc}, y_\text{ndc}, z_\text{ndc}) = (\frac{x}{w}, \frac{y}{w}, \frac{z}{w})
$$

This yields the coordinates within the **canonical view volume**. Since every surviving clip coordinate $(x, y, z, w)$ satisfies the clipping inequalities (e.g., $-w \leq x \leq w$), every component of the resulting NDC coordinate is guaranteed to lie in the interval [-1, 1][^userdefinedclipping].

[^userdefinedclipping]: Additionally, user-defined clipping is configurable, which allows for custom clipping planes to be added to the scene <Cite name="KSS17" pp="228 f." />.

The **Canonical Unit Cube**, or _canonical view volume_ <Cite name="RTR" pp="94" / >, defined by the interval $[−1,1]$[^floatingpoint] on all three axes, is the space for Normalized Device Coordinates in OpenGL.

[^floatingpoint]: Mathematically, the NDC cube is a continuous space containing an uncountable set of real numbers. These values are represented by a finite set of discrete floating-point numbers (typically IEEE 754 32-bit floats) that approximate the ideal real values.

In the rendering pipeline, NDCs are produced by applying the perspective divide $(\frac{x}{w}, \frac{y}{w},\frac{z}{w})$ to the clip space coordinates that result from the projection transform. With orthographic projection, it follows that $w=1$. The coordinates resulting from this normalization step are then mapped to the user's specific device resolution (see <Cite name="LGK23" pp="Fig. 5.36, 181" / >).

When using orthographic projection, the _clip space_ falls together with the NDCs, as the perspective division by the fourth homogeneous $w$-coordinate is applied, but does not change the $x,y,z$-coordinates (see <Cite name="SWH15" pp="72" />).

:::info NDCs and the Viewing Volume
In <Cite name="SWH15" pp="40 f." />, _Sellers et al._ note that the practically visible range is described by $z$
in $[0,1]$, and that this also applies to the NDC $z$-axis. However, other literature explicitly refers to a range of $[-1, 1]$ in all directions (e.g., <Cite name="RTR" pp="94" />, <Cite name="LGK23" pp="174" />).

It can therefore be assumed that the authors may refer to a range controlled by `glClipControl` <Cite name="KSS17" pp="230" />, which allows for changing the NDC depth convention from $[-1, 1]$  to $[0, 1]$.
:::

## Orthographic Projection
When we apply orthographic projection, points are projected onto an arbitratry plane.

Visually, it appears as if we are reducing the vector space by one dimension. A key property is that parallel lines remain parallel, regardless of the camera's orientation, and the perspective component is eliminated.

To explain this intuitive sense of depth and the apparent contradiction with parallel lines, the example of railroad tracks is often used: While we can assume that railroad tracks are parallel not only at the observer's standpoint but also a kilometer in the distance, the effect of depth makes it seem as though the tracks converge at a single point, known as the _vanishing point_ (see Figure <Figure idx={figures.railroad_tracks} />).

<Embed
    modeAware={true}
    figref={figures.railroad_tracks}
    title={
        "The left side shows an orthographic (top-down) view of a spectator and railroad tracks. In this objective view, parallel lines remain parallel. The right side shows a perspective view from the spectator's vantage point. Here, the parallel tracks recede into the distance, appearing to converge at a vanishing point and demonstrating how our eyes perceive depth. (Source: own)"}>
    <img src={railroad_tracks}  />
</Embed>

For eliminating the z-component of any given $\vec{v} \in \mathbb{R}^3$, we can use the following matrix:

$$
\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 1\\
 \end{pmatrix}
$$

From this matrix form it immediately folows that any homogenous vector $\vec{v} = (x, y, z, 1)^T$ multiplied with this matrix yields a vector $\vec{v'}$ with its z-component set to $0$:


$$
\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 1\\
 \end{pmatrix} \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x \\ y \\ 0 \\ 1 \end{pmatrix}
$$

To project onto an arbitryry z-plane, we use the z-component of the 4 column in the matrix and construct a transformation matrix

$$
\boldsymbol{M_o} =
\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & z_p\\
0 & 0 & 0 & 1\\
 \end{pmatrix}
$$

This gives us



$$
\boldsymbol{M_o} \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} =
  \begin{pmatrix}
  (1, 0, 0, 0)^T \cdot (x, y, z, 1)^T \\
  (0, 1, 0, 0)^T \cdot (x, y, z, 1)^T \\
  (0, 0, 0, z_p)^T \cdot (x, y, z, 1)^T \\
  (0, 0, 0, 1)^T \cdot (x, y, z, 1)^T
  \end{pmatrix} =
  \begin{pmatrix} x \\ y \\ z_p \\ 1 \end{pmatrix}
$$

We can easily derive that any vector computed by this must be perpendicular to the plane given by the vectors $(x, 0, 0)^T$ and $(0, y, 0)^T$, since their crossproduc yields

$$
\begin{pmatrix} x \\ 0 \\ 0 \end{pmatrix} \times \begin{pmatrix} 0 \\ y \\ 0 \end{pmatrix} =
\begin{pmatrix} 0 \\ 0 \\ xy \end{pmatrix}
$$

which is a vector $\vec{xy}$ with  $|\vec{xy}| = sin(\theta) |\vec{x}| |\vec{y}|$.

It is easily shown that this vector is parallel to $(0, 0, z_p)^T$ since

$$
\begin{pmatrix} 0 \\ 0 \\ xy \end{pmatrix} \times \begin{pmatrix} 0 \\ 0 \\ z_p \end{pmatrix} =
\begin{pmatrix} 0 \\ 0 \\ 0 \end{pmatrix}
$$


The effect of projecting the points of a (wireframed) cube is shown in the animations <Figure idx={figures.ortho_proj_cube_iso} />, <Figure idx={figures.ortho_proj_cube_persp_front} />,  <Figure idx={figures.ortho_proj_cube_ortho_front} />.



<Embed
    modeAware={true}

    figref={figures.ortho_proj_cube_iso}
    title={
        "An isometric view showing a cube being orthographically projected onto the highlighted plane at z=-4."}>
  <img style={{maxWidth : 600}} src={ortho_proj_cube_iso}   />
</Embed>

<Embed
    modeAware={true}
    width={600}
    figref={figures.ortho_proj_cube_iso}
    title={
        "Here, the same scene is rendered with a direct orthographic view, eliminating all perspective. This illustrates the final 2D image as it would appear on a screen if the camera was directly in front of the cube."}>
    <img style={{maxWidth : 600}} src={ortho_proj_cube_ortho_front}  />
</Embed>

<Embed
    modeAware={true}
    figref={figures.ortho_proj_cube_iso}
    title={
        "Instead of rendering the entire scene orthographically, we first project it onto z=-4 and then visualize this 2D result with a perspective camera on the negative z-axis, an optical axis orthogonal to the plane."}>
    <img style={{maxWidth : 600}} src={ortho_proj_cube_persp_front}  />
</Embed>

<details>
<summary>Plot-Code (Python)</summary>

<CodeBlock language="python">
  {orthogonal_projection_code}
</CodeBlock>

</details>

### Affine Transformation

The statement that two parallel vectors $\vec{p}, \vec{q}$ remain parallel  after an orthographic projection is applied is a fundamental property of an **affine transformation** <Cite name="VB15" pp="118" />.

An affine transformation $\boldsymbol{T}$ is a transformation of the form

$$
\vec{v'} = \boldsymbol{T}(\vec{v}) = \boldsymbol{L}(\vec{v}) + \vec{x}
$$

where $\boldsymbol{L}$ is a linear transformation. Hence, an affine transformaton is simply a linear transformation to which a translation is applied.

Intuitively, we can see that this statement holds. Given two parallel vectors:

$$
\vec{p} = \begin{pmatrix}x \\ y \\ z \end{pmatrix}, \ \vec{q} = \begin{pmatrix}x' \\ y' \\ z' \end{pmatrix}
$$

Their cross product is the zero vector

$$
\vec{p} \times \vec{q} = (x, y, z)^T \times (x', y', z')^T = (yz' - zy', zx' - xz', xy' - x'y) = \vec{0}
$$

which yields three initial conditions:

$$
yz' - zy' = 0 \Leftrightarrow yz' = zy' \\
zx' - xz' = 0 \Leftrightarrow zx' = xz' \\
xy' - x'y = 0 \Leftrightarrow xy' = x'y \\
$$

Obviously, removing the z component from $\vec{p}$ and $\vec{q}$ preserves the parallelism for the $xy$-plane, as the third component of the cross product is still zero:

$$
\begin{pmatrix} x \\ y \\ 0 \end{pmatrix} \times \begin{pmatrix} x' \\ y' \\ 0 \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \\  xy' - x'y = 0 \end{pmatrix} = \vec{0}
$$

Our intutiotn tells us that since these new vectors are parallel, translating both by an equal amount in the same direction will not change their parallelism. Therefor, adding the same z-component $(0, 0, z_p)^T$ to both vectors yields to parallel vectors

$$
\vec{p'} = \begin{pmatrix}x \\ y\\ z_p \end{pmatrix}, \vec{q'} = \begin{pmatrix}x' \\ y'\\ z_p \end{pmatrix}
$$

This intuition can be formalized using the definiton of an affine transformation. We can write our orthographic projection Matrix $\boldsymbol{M_o}$ as an affine transformation $\boldsymbol{T}$ consisting of the sum of a linear combination


$$
\boldsymbol{L}(\vec{v}) = \begin{pmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 &0 \end{pmatrix} \begin{pmatrix}v_0 \\v_1 \\v_2 \end{pmatrix} = \begin{pmatrix} v_0 \\ v_1 \\ 0 \end{pmatrix}
$$

and a translation vector $\vec{z_p}$. That affine transformations preserve parallelity will be shown for the general case in the next section.

### Proof that Affine Transformations preserve Parallelity

:::note Proof
Let $\boldsymbol{T}$ be an affine transformation

$$
\boldsymbol{T}(\vec{v}) = \boldsymbol{L}(\vec{v}) + \vec{z_p}
$$

Let's define two lines $p_l$, $q_l$ with direction vectors $\vec{p} = P_2 - P_1$ and $\vec{q} = Q_2 - Q_1$, where $P_i, Q_i$ are points on the respective lines.

Since the lines are parallel, we can write $\vec{p}$ as the scaled version of $\vec{q}$

$$
\vec{p} = k \vec{q},\ k \in \mathbb{R}
$$



Applying the affine transformation to the points $P_1$ and $P_2$ yields a new vector with direction $\vec{p}''$:

$$
\begin{alignat*}{3}
\vec{p'} &= T (P_2) - T(P_1) \\
&= (\boldsymbol{L}(P_2) + \vec{z_p}) - (\boldsymbol{L}(P_1) + \vec{z_p})\\
&= \boldsymbol{L}(P_2) - \boldsymbol{L}(P_1)
\end{alignat*}
$$

Since $\boldsymbol{L}$ is a linear transformation, we can simplify this to

$$
\vec{p'} = \boldsymbol{L}(P_2) - \boldsymbol{L}(P_1) = \boldsymbol{L}(P_2 - P_1) = \boldsymbol{L}(\vec{p})
$$

This shows that the new direction vector is the result of applying the linear part of the transformation to the original direction vector.
Applying the same computation to $q_l$ gives us

$$
\vec{q'} = \boldsymbol{L}(Q_2) - \boldsymbol{L}(Q_1) = \boldsymbol{L}(Q_2 - Q_1) = \boldsymbol{L}(\vec{q})
$$

Since we know $\vec{p} = k \vec{q}$, we can therefore conclude:

$$
\vec{p'} = \boldsymbol{L}(\vec{p}) = \boldsymbol{L}(k \vec{q}) = k \boldsymbol{L}(\vec{q}) = k \vec{q'}
$$

Hence, $\vec{p}'$ is the $\vec{q}'$ scaled by $k$, which shows that they are parallel. This proves that any affine transformation $\boldsymbol{T}$ preserves parallelism. $\Box$
:::


### Deriving the Orthographic Projection Matrix

In the following, we will derive the orthographic projection matrix required to map an arbitrary cubic volume $\boldsymbol{V}$ from view space coordinates[^fromviewspace] to the canonical view volume $\boldsymbol{U}$.

[^fromviewspace]: The projection occures _after_ the view/camera space transformation.

We begin with defining the coordinates of the Volume $\boldsymbol{V}$ to be projected (see <Figure idx={figures.unitcube} />):

$$
\begin{alignat*}{3}
l \qquad &(\text{left})\\
r \qquad &(\text{right})\\
b \qquad &(\text{bottom})\\
t \qquad &(\text{top})\\
n \qquad &(\text{near})\\
f \qquad &(\text{far})
\end{alignat*}
$$



The naming convention applies _after_ the transformations to camera space. In this space, the camera is located at the origin $(0, 0, 0)$, looking down the negative $z$-axis. $\boldsymbol{V}$ is defined by coordinates relative to the z-axis. <Figure idx={figures.unitcube} /> shows therefore a representation of camera space.


Note that $n$, $f$ represent positive distances to the _near_ and _far_ clipping planes. By definition, the near plane is closer to the origin, so $n < f$.

However, in camera space where the view direction is along the negative $z$-axis, these values correspond to negative coordinates. The near plane is located at

$$
z_\text{near} = -n
$$

The far plane is located at

$$
z_\text{far} = -f
$$

Therefore, the following holds:

$$
z_\text{near} > z_\text{far}
$$


When deriving the coordinates for the canonical view volume, OpenGL requires a left handed coordinate system, that is, the view direction is along the positive instead of the negative $z$-axis. For our case this means that we have to mirror the $z$-axis at the origin, which will be considered by using a negative $z$-component in the following orthographic projection matrix (see <Cite name="RTR" pp="95" />).

We will first examine the requirements for the affine transformation. Since all vertices of V must fit into the unit cube $[−1,1]^3$, which is - most likely contrary to $\boldsymbol{V}$ - located at the origin,  a translation and a scaling are necessary. Thus, we can directly define a transformation matrix of the form

$$
\begin{pmatrix}
    \boldsymbol{S} & \vec{t} \\
        0           & 1
\end{pmatrix}
$$

where  $\boldsymbol{S}$ is the $3 \times 3$ scaling matrix and $\vec{t}$ is the translation vector.


We thus obtain the affine transformation that, when multiplied by an arbitrary vertex $(x, y, z, 1)^T$, transforms it into the canonical view volume:

$$
\begin{pmatrix}
a_x & 0  &  0 & b_x \\
0 & a_y  &  0 & b_y \\
0 & 0  &  -a_z & b_z \\
0 & 0  &  0 & 1 \\
\end{pmatrix} \begin{pmatrix} x \\ y\\ z \\ 1 \end{pmatrix} =  \begin{pmatrix} a_xx+b_x \\ a_yy+b_y\\ -a_zz+b_z \\ 1 \end{pmatrix}
$$

Here, we have negated the $z$-component, as we must mirror the $z$-axis (see above).

From this, we can derive a system of linear equations for which the following conditions must be met:

$$
\begin{alignat*}{3}
a_xl + b_x = -1 \ &\land a_xr + b_x = 1 && \qquad (\text{x-Axis})\\
a_yb + b_y = -1 \ &\land a_yt + b_y = 1 && \qquad (\text{y-Axis}) \\
-a_z\cdot (-n) + b_z = -1 \ &\land -a_z\cdot (-f) + b_z = 1 && \qquad (\text{z-Axis}) \\
\end{alignat*}
$$

We explicitly use $-n$ and $-f$ here because after the view transformation, the _near_ and _far_ values are given to us as positive distances. For the correct derivation, they must therefore be re-inserted as negative values.

Solving for $l$ and $r$, respectively, yields:

$$
\begin{alignat*}{3}
a_xl + b_x = -1 & \Leftrightarrow b_x = -1 - a_xl\\
\\
a_xr + b_x = 1 & \Leftrightarrow b_x = 1 - a_xr
\end{alignat*}
$$

Substituting $b_x$ with $-1 - a_xl$ gives us

$$
\begin{alignat*}{3}
a_xr -1 - a_xl = 1 & \Leftrightarrow a_xr - a_xl = 2\\
\\
 & \Leftrightarrow a_x = \frac{2}{r - l}
\end{alignat*}
$$

Solving analogously for $a_y$ and $a_z$, we obtain

$$
\begin{alignat*}{3}
a_x &= \frac{2}{r - l}\\
\\
a_y &= \frac{2}{t - b}\\
\\
a_z &= \frac{2}{f - n}
\end{alignat*}
$$

We can now solve for $b_x, b_y, b_z$. We obtain

$$
\begin{alignat*}{3}
b_x &= -\frac{r+l}{r - l}\\
\\
b_y &= -\frac{t+b}{t - b}\\
\\
b_z &= -\frac{f+n}{f - n}
\end{alignat*}
$$

Which results in the orthographic projection matrix


$$
\boldsymbol{T} = \begin{pmatrix}
\frac{2}{r - l} & 0  &  0 & -\frac{r+l}{r - l} \\
0 & \frac{2}{t - b}  &  0 & -\frac{t+b}{t - b} \\
0 & 0  &  -\frac{2}{f - n} & -\frac{f+n}{f - n} \\
0 & 0  &  0 & 1 \\
\end{pmatrix}
$$
<br />

:::info Where is the Projection Plane?
The _near_ plane is called the "image plane" by the Red Book: It's the plane closest to the eye and perpendicular to the line of sight (see <Cite name="KSS17" pp="902" />). _Lehn et al._ equally describe the projection plane  identical to the near clipping plane <Cite name="LGK23" pp="167" />.<br />
 As such, with orthographic projection, rays from vertices of the view volume in camera space intersect the _near_ plane perpendicularly. Then, after the orthographic projection is applied, clip space coordinates are transformed into the Canonical View Volume and NDCs, where the perpendicular relationship is preserved due to the parallelism-preserving properties of affine transformations. Consequently, the projection rays remain perpendicular to the $xy$-plane at $z=-1$ in NDC space.
:::


#### Proof that (l, b, -n, 1) maps (-1, -1, -1, 1)

Let $\vec{v}$ be the homogeneous coordinate $(l, b, -n, 1)$ with $l, b, n \in \mathbb{R}$ (view space coordinates). We can then solve with $\boldsymbol{T}\vec{v}$ for

$$
\begin{pmatrix}
\frac{2}{r - l} & 0  &  0 & -\frac{r+l}{r - l} \\
0 & \frac{2}{t - b}  &  0 & -\frac{t+b}{t - b} \\
0 & 0  &  -\frac{2}{f - n} & -\frac{f+n}{f - n} \\
0 & 0  &  0 & 1 \\
\end{pmatrix} \begin{pmatrix} l \\ b \\ -n \\ 1 \end{pmatrix}
= \begin{pmatrix}
\frac{2l}{r - l} -\frac{r+l}{r - l} \\
\frac{2b}{t - b} -\frac{t+b}{t - b} \\
-\frac{-2n}{f - n} -\frac{f+n}{f - n} \\
 1
\end{pmatrix} = \begin{pmatrix}
-\frac{r - l}{r - l}  \\
-\frac{t-b}{t - b} \\
-\frac{f-n}{f - n} \\
1 \end{pmatrix} = \begin{pmatrix} -1 \\ -1 \\ -1 \\ 1 \end{pmatrix}
$$

$\Box$

We can analogously show that  $(r, t, -f, 1)$ maps $(1, 1, 1, 1)$.


## Perspective Projection

:::warning How the third component is used in NDC
Depth Test
:::

-------------