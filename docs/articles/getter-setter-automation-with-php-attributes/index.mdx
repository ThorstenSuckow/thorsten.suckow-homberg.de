---
title: "Accessor Automation with PHP Attributes"
description: Getters and Guarded Setters Automation with PHP attributes
---

import {GlosRef} from "../../../src/components/References";
import {Embed}  from "../../../src/components/Embed";


## 1. Abstract

This article introduces getter and setter automation based on **PHP Attributes**, **Traits**
and **Constructor Property Promotion** for **PHP >= 8.2** and demonstrates how boilerplate code can be reduced where classes
require simultaneously property access encapsulation and guarded setters.

The article also gives details on challenges one faces when access modifiers have to be considered, and when the scope
 of a given callee has to be validated with permissions to update various properties that may not reside in the scope of the callee.

The impacts of getter/ setter automation on performance is demonstrated with benchmarks that compare various levels of details of such an implementation.


### 1.1 Notation
For a typed property `employee`, we may construct setters and getters such that `setEmployee(T $value)` has write-access and `getEmployee(): T`
has read-access.

In the following text, the generalization of such getters and setters uses abbreviations `set*()` and `get*()`, with `* = "\$(A-Z)[a-zA-Z0-9_]*"`.

For semantic purposes, we introduce `is*()` as a representant of a method with read-access to a `boolean` property.

This article mentions "physical" and "virtual" existing methods. In the context of the topic of this article, a "phsical" method
refers to a method that is explicitly implemented with the source code. A "virtual" method refers to a method that is resolved by
`PHP`'s magic method [`__call`](https://www.php.net/manual/en/language.oop5.overloading.php#object.call). In this regard,
the term shares shares similiarities with the concept of `virtual functions`, where the target function is not known during compile time.


## 2. Introduction

**Encapsulation** in object-oriented programming is often connotated with implementing `getters` and `setters` for data,
and falsely so with **data hiding**: Reducing the visibility of class-properties with access-modifiers like
 `private` and `protected` and later exposing the same with appropriate `get`- and `set`-methods is by no means an act of hiding
data - it simply is **Encapsulation** in its purest form and, even if rightly so applied - often such classes
 benefit in no way from providing such methods. More so, if the data of a class changes
and the interface is already used in the system (eventually leaking across module boundaries), it will be hard to change
the implementation without adding new code and letting the old rot. Instead of simply refactoring class internals where a
meaningful interface supports such an abstraction, classes tend do grow or introduce breaking changes.

A complete set of `getters` and `setters` aligning with available properties may caress the ego of a developer or a project's coding
standards, but bloats the source code and reduces its readability. One may doubt that it supports the conceptual context
the class is used with:

```php title="Employee.php"
class Emplyoee
{

    private string $empId;

    private string $name;

    public function __construct(string $empId, string $name)
    {
        $this->setEmpId($empId);
        $this->setName($name);
    }

    public function setEmpId(string $empId): void
    {
        $this->empId = $empId;
    }

    public function getEmpId(string $empId): string
    {
       return $this->empId;
    }

    public function setName(string $name): void
    {
        $this->name = $name;
    }

    public function getName(string $name): string
    {
        return $this->name;
    }

    // ...
}
```

In the example above, the code for the `Employee` is has **getters** and **setters** exposing
the existence of properties when following the (non-formalized) notation of `get*()`/ `set*()` / `is*()`, helping data
mappers and serializers when reconstituting or creating owning objects.

However, such methods don't promote the means of a model of a particular domain and not seldom are programmers tempted to implement logic or
behavior in places preceding such an API. In fear of breaking functionality when `setters` unexpectedly implement logic for either updating (associated) data or
using constraints on the submitted data, this often leads to <GlosRef name="anemic domain models" file="ddd.anemicdomainmodel" />.

```php
$employee = new Employee();

$employee->setSalaryClass(Salary::EL13);
$employee->setRole(CompanyRole::ITResearch);

// instead of
// $employee->promoteTo(CompanyRole::ITResearch);
```

Often enough can we witness projects where business logic finds its way into <GlosRef name="Facades" file="sd.facade" />,
whereas such business logic would have its rightful place in the <GlosRef name="Entity" file="sd.entity" /> itself (in this case the `Employee`-class).

In the following article I will show how **PHP8** can be used to reduce such boilerplate code, by still conforming to the needs
 of data mappers and without losing access to (selected) properties of an object. Additionally, I will demonstrate how
 **guards** can be implemented with having responsibility for constraining possible data changes.

## 3. PHP Attributes
[Attributes](https://www.php.net/manual/en/language.attributes.overview.php) were introduced with **PHP8** and can be
used to provide metadata information. While this was already possible with doc-block comments and annotations in previous
 versions of **PHP**, **PHP Attributes** allow to do the same in a more formal context. Similar to **Java**, where [**Annotations**](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/text/Annotation.html)
  have their own type and can be embedded directly into code, **PHP Attributes** do not need doc-blocks, making parsers
  obsolete. The [Reflection API](https://www.php.net/manual/en/class.reflectionattribute.php) allows for reading
  out **Attributes** preceding classes, methods or properties.

For our purpose, we define two classes that serve as _**tagging Attributes**_: They will be used for identifying
properties that require **getters** and **setters** to be available as part of their host's interface.

```php title="Setter.php"
#[Attribute]
class Setter
{
}
```


```php title="Getter.php"
#[Attribute]
class Getter
{
}
```

## 4. The AccessorTrait
Any client interested in updating or querying data from an object whose properties are attributed with `#[Setter]` and
`#[Getter]` should be able to use particular `get`- and `set`-methods.

Since our server will not implement these methods directly, we need to facilitate PHP's [`__call()`](https://www.php.net/manual/en/language.oop5.overloading.php#object.call).
The method will be implemented in a [Trait](https://www.php.net/manual/en/language.oop5.traits.php) which generally provides
code reusabilty in **PHP** without using inheritance or object composition.

:::info
The following version of `AccessorTrait` will only showcase the basic implementation. For a complete
example, see [this file](https://github.com/quant-php/quant/blob/main/src/Traits/AccessorTrait.php).
:::

```php title="AccessorTrait.php"
trait AccessorTrait
{
    public function __call($method, $args): mixed
    {
        if (($isSetter = str_starts_with($method, "set")) ||
            str_starts_with($method, "get")) {

            $property = lcfirst(substr($method, 3));

            if ($isSetter) {
                if ($this->hasSetterAttribute($property)) {
                    $this->applyFromSetter($property, $args[0]);
                    return $this;
                }
            } else  {
                if ($this->hasGetterAttribute($property)) {
                    return $this->$property;
                }
            }
        }

        throw new BadMethodCallException("$method not found.");
    }
}
```

`__call()` will be available to the host implementing the Trait: Whenever a method is called that is not available on the
target object, **PHP** will pass pass the requested method name along with any submitted arguments to this method. In our case,
`__call` inspects the requested method-name for a `get`-/`set`-prefix, and, if available, queries the host for properties
attributed with `#[Setter]` or `#[Getter]`. Properties can in this case be either properties defined directly in the host's
class, or -  using [**Constructor Property Promotion**](https://www.php.net/manual/en/language.oop5.decon.php#language.oop5.decon.constructor.promotion) - with the parameters defined in the host's constructor.

### 4.1 Hosting the AccessorTrait

As a requirement, we want the `empId` of the previously introduced `Employee`-class to be available with `getEmpId()`: Once provided with the constructor, this property will be immutable for the lifetime of the associated `Employee`.class
Using the available `#[Getter]`-Attribute along with [**Constructor Property Promotion**](https://www.php.net/manual/en/language.oop5.decon.php#language.oop5.decon.constructor.promotion), our implementation looks like this:

```php title="Employee.php"
class Employee {

    use AccessorTrait;

    #[Getter]
    private string $name = "John Smith";

    public function __construct(
        #[Getter]
        private string $empId
    ) {
    }
}
```

Creating an instance and immediately accessing the `$empId` declared as `private` is now possible due to the `AccessorTrait`:

```php
$employee = new Employee("87i-dsd-89z-978");
$employe->getEmpId(); // returns "87i-dsd-89z-978"
```

Also, read-access to `$name` is nor provided by `getName()`.

As expected, a call to `setEmpId()` throws a `BadMethodCallException`: It's neither defined in `Employee`, nor is it
considered with `AccessorTrait::__call()` since the `#[Setter]`-attribute is missing.

However, it should be possible to change the `$name` of `Employee`: Adding the `#[Setter]`-attribute to its property yields in
 the availability of `setName()` with any instance of `Employee`:

```php title="Employee.php"
class Employee {

    use AccessorTrait;

    #[Setter] #[Getter]
    private string $name = "John Smith";

    public function __construct(
        #[Getter]
        private string $empId
    ) {
    }
}
```

Setting `$name` is now possible by calling `setName()`.

```php
$employee = new Employee("87i-dsd-89z-978");
$employe->setName("Thomas Anderson");
```

Instead of configuring individual properties of a target class, it is also possible to use the attributes on class level: accessors
will then automatically be available **for all** properties of the class.

### 4.2 Conditional Updates of Properties with Guards

Without the need to provide boilerplate-code for `setters`, how can we make sure that data passed to such `setters` matches
specific criteria so that updating the targeted property does not leave the hosting object in an invalid state? Delegating
the responsibility to invoke `set*()` by the `AccessorTrait`, we may proxy such calls with an `apply*()`-method,
which - if available on the host - gets called before the property gets actually assigned a new value. The `apply*()`-method -
conforming to the naming conventions of `get` and `set` - must then test the passed value against any criteria available,
then return the new value - indicating a pass, thus a successful update of the property's value.

```php title="Employee.php"
class Employee {

    use AccessorTrait;

    #[Setter] #[Getter]
    private string $name = "John Smith";

    /**
     *  @throws ValueError
     */
    protected function applyName(string $value): string
    {
        if ($value === "") {
            throw new ValueError("Empty name is not allowed");
        }

        if ($value === "John Smith") {
            return $this->name;
        }

        return $value;
    }
}
```

For making this work, the `AccessorTrait` has a method `applyFromSetter()` implemented:

```php title="AccessorTrait.php"

public function __call($method, $args): mixed
{
    // ...

    if ($isSetter) {
        if ($this->hasSetterAttribute($property)) {
            $this->applyFromSetter($property, $args[0]);
            return $this;
        }
    }

    // ...
}

private function applyFromSetter(
    string $property,
    mixed $value
): void {
    $applier = "apply" . ucfirst($property);

    $newValue = $value;
    if (method_exists($this, $applier)) {
        $newValue = $this->{$applier}($value);
    }
    $this->$property = $newValue;
}

```

The method checks if a **guard** - i.e. an `apply*()`-method is available - calls it with value submited to `set*()`,
then uses its return value as the new value for the property. If no **guard** is available, the original value
will be used as the new value.

:::note
The new value might by the same as the old value, making it harder to determine whether the returning value is equal to
the value that was submitted to `set*()` in the first place. Lacking a bottom value in **PHP** like `undefined` requires
us to introduce a custom type to indicate that updating the value was forbidden.
:::

### 4.3 Guarding constructor arguments
To utilize the various `apply`-methods that might be available with the implementation, a constructor can invoke
the `applyProperties`-method available with the **AccessorTrait**: This will immediately apply any method guarding a property
and assign the computed value:

```
 public function __construct(
        private string $a,
        #[Setter]
        private string $b
    ) {
        $this->applyProperties([1 => $b]);
    }
```

`applyProperties` expects a numeric array and will identify any property positionally. In the example above, the guard for
 the class-property `$b` will be invoked with the value submitted with the constructor argument `$b`.

### 4.4 Access Modifiers to getters and setters
To modify the visibility of any accessor created with the `#[Getter]` / `#[Setter]` annotation, modifier configuration can be achieved
with applying arguments to the attributes themself: **PHP** provides means to pass additional information to attributes which
end up as constructor arguments when [`newInstance()`](https://www.php.net/manual/en/reflectionattribute.newinstance) is invoked
on a particular attribute. This does not necessarily mean that an Attribute has to consider constructor arguments - this syntax can
be adopted for simply tagging an Attribute with additional information:

```php title="Using tagging Arguments with Attributes"
#[Attribute(TaggingClass::TagName, AnotherTaggingClass::AnotherTag)]
```

Treating such arguments in a semantic context, we can provide a set of modifiers that can be used to further describe
the access level of a generated getter or setter. Consider the following implementation, where an enum `Modifier` exists
that provides the values `PUBLIC`, `PRIVATE`, `PROTECTED`. Describing a class that has only private `setters`
and `public` getters can then be achieved by

```php
#[Getter(Modifier::PUBLIC)]
#[Setter(Modifier::PRIVATE)]
class A
{
    use AccessorTrait;

    private string $value = "";
}
```

This will provide public access to `getValue()` of instances of `A`, but only private access to the corresponding `setters`
of `$value`. Thus, changing the values is reserved to `A` itself. Changing `#[Setter(Modifier::PRIVATE)]` to `#[Setter(Modifier::PROTECTED)]`
would then broaden access to `$value` to any instance of classes extending `A`.

The current implementation allows for overriding class level attributes with property level attributes: If one wishes to
provide `protected` instead of `private` access to the setter of `$value` in the example above, an additional attribute would be required:

```php
#[Getter(Modifier::PUBLIC)]
#[Setter(Modifier::PRIVATE)]
class A
{
    use AccessorTrait;

    #[Setter(Modifier::PROTECTED)]
    private string $value = "";
}
```


:::info
Since the `AccessorTrait` implements any conceivable logic and behavior, additional modifiers like `Modifier::PACKAGE`
could be used for restricting accessor visibility to the namespace the implementing class belongs to.
:::

### 4.5 Inheritance and Scoping
The implementation allows for defining the `AccessorTrait` once for a class, and all subclasses using the attributes
 provided are then properly considered when the `setter`-/`getter`-automation is invoked.

 Since traits are basically code templates enabling horizontal code composition without affecting inheritcance,
 the resulting class constructs and their implementation behave just like as if the code of the Trait was part of the source
  code of the target class. This results in poarticular in challenges for resolving the scope the `setter`/`getter` and - when
  modifiers such as `PROTECTED` and `PRIVATE` are used on the attributes, challenges for determining whether the calls
  to the virtual accessors are allowed in the first place.

import Scoping from './img/scoping.png';

<Embed
    title={"The Trait has to take care of finding attributed properties and scope function calls accordingly.."}
>
    <img src={Scoping} />
</Embed>

Specially the calling scope of magic methods [has been discussed](https://github.com/php/php-src/issues/9906) and resulted in a
[RFC scheduled for 8.3](https://wiki.php.net/rfc/access_scope_from_magic_accessors).

In addition, modifiers have to be treated in accordance to the language level behavior of PHP, using `debug_backtrace()`
for accessing runtime information on the call stack:

```php
 $bt = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 3);
 if ($accessLevel === Modifier::PRIVATE && $bt[2]["class"] !== $declaringClass) {
    return false;
}
```

This does not severely impact performance, but the need for accessing a rather expensive function belonging to a debugging domain
 shows that **PHP** can benefit from additional runtime information with magic methods as discusses in the RFC quoted above.
 Further optimizations given builds that use code generation are discussed later in this article.

### 4.6 Static Code Analysis

The implementation provides extensions for [**PHPStan**](https://github.com/phpstan/phpstan) so that white-box tests on static code
 properly resolves calls to getters and setters not available with the source code.

To make this work,several classes have to be implemented, of which the most notabke are:

- `PHPStan\Reflection\MethodReflection` <br /> provides information about virtual methods proxied by `__call`. Of interest are the
function variants returned for the `set`- and `get`-context which futher provide information about parameters accepted and the return value for either `setter` or `getter`: For a `setter`, this must be the declaring class itself; for a `getter`, the type of the property that is quried by the getter.

- `PHPStan\Reflection\MethodsClassReflectionExtension` <br /> A predefined interface for implementations facilitating `__call`, [MethodsClassReflectionExtension](https://phpstan.org/developing-extensions/class-reflection-extensions#methods-class-reflection-extensions)
greatly reduces the required effort (e.g. custom rules) for implementing the constraints on magic method calls. The logic
for that has to be implemented for the interface's `hasMethod()`/ `getMethod()` is similar to that found with the `AccessorTrait`,
minus the code required for determining the calling scope, which is statically resolved by the engine used by **PHPStan**

- `PHPStan\Rules\Properties\ReadWritePropertiesExtension` <br /> This extension interface is used to describe always-read or always-written properties to prevent `never read` / `unused`
warnings.  The extension for **quant** checks whether the attributes property is used with a class that uses the `AccessorTrait`
and optimistically returns `true` for the `isAlwaysRead()`-, `isAlwaysWritten()`- and `isInitialized()`- checks.

## 5 . Performance considerations

The implementation details described in this article require logic and information to be evaluated at runtime, since
`getters` / `setters` are only virtually existing, not physically: This affects performance to a certain degree which we
 will examine below.

The following functionality of the `AccessorTrait` was found to impact runtime performance: <a name="performance_impacts"></a>

 1. Using the [Reflection API](https://www.php.net/manual/en/book.reflection.php) to query properties and classes for properties.
 2. Determining whether an accessor is accessible for the callee based on the modifiers-configuration of the attributes.
 3. Scoping function calls from the class that hosts the trait to the classes that declare the property.


### 5 .1 Benchmark Test Cases
To get an idea of how the runtime of the `AccessorTrait` compares to related implementations, the following Test Cases
where measured using [phpbench](https://phpbench.readthedocs.io/en/latest/index.html), and open source benchmark tool for **PHP**:

1. Calls to a `setter`-method physically existing on a class.
2. Calls to a method magically resolved by `__call`.
3. Using [`Doctrine\Common\Annotations::AnnotationReader`](https://www.doctrine-project.org/projects/annotations.html) to parse Docblocks and read annotation, then map the annotation to a method-call intercepted by `__call`
4. Using `AccessorTrait` to get the Attribute of a property, the map the name of the property to a method-call intercepted by `__call`
5. Using instances of a class hierarchy with multiple calls to getters and setters physically available with the classes
6. The same as 5., but getters and setters are only virtually existing; the `AccessorTrait` is part of the root-class

#### 5 .1.1 Benchmark Settings
For each benchmark, a [Revolution](https://phpbench.readthedocs.io/en/latest/annotributes.html?highlight=revs#revolutions) of `1000` is used that gets [iterated](https://phpbench.readthedocs.io/en/latest/annotributes.html?highlight=revs#iterations) `5` times.
Using a [retry-threshold](https://phpbench.readthedocs.io/en/latest/annotributes.html?highlight=revs#retrythreshold) of `2` narrows down the deviation for which samples are treated valid.

[Warm Ups](https://phpbench.readthedocs.io/en/latest/annotributes.html?highlight=revs#warm-up) are skipped to make sure at least the first sample has the benchmarked code processed with the opcode-cache.

```bash
$ vendor/bin/phpbench run Tests/Benchmarks --report=aggregate --retry-threshold=2
```

<details>
<summary>Test Environment</summary>

| System | Value|
|----------|---------------------|
|Hardware	|AMD Ryzen 9 5900X (amd64), 64GB RAM |
|Docker provider |docker 20.10.21|
| Runtime | php PHP8.2.3,  nginx-fpm, xdebug ❌, opcache ✔|
| DDEV version    | v1.21.6|

</details>


### 5 .2 Results

| benchmark                                                      | revs | its | time         | rstdev |
| -------------------------------------------------------------- | ---- | --- | ------------ | ------ |
| 1. `setA(string $s)`                                           | 1000 | 5   | **4.956μs**  | ±1.04% |
| 2. `__call: _$this->{$method} = $args[0];`                     | 1000 | 5   | 5.114μs      | ±1.09% |
| 3. `Doctrine\Common\Annotations::AnnotationReader -> __call()` | 1000 | 5   | **1.689ms**  | ±1.25% |
| 4. `AccessorTrait::getBPublic()`                               | 1000 | 5   | 18.566μs     | ±1.54% |
| 5. implemented getters / setters                               | 1000 | 5   | 16.397μs     | ±1.15% |
| 6. attributed getters / setters                                | 1000 | 5   | 60.786μs     | ±1.04% |

### 5 .3 Observations

Not surprisingly, the native implementation of a setter (1.) is the fastest with **4.956μs**, with the magic method (2.) only slightly slower.

The **AnnotationReader** is the slowest benchmark with **1.689ms**, obviously due to the fact that text parsers are involved, conversely to (6.),
where attribute parsing is natively implemented: The benchmark for the complex test case using the `AccessorTraits` requires **60.786μs** to finish.
It is worth mentioning that the classes for the benchmark depict more [complex use cases](#performance_impacts) with inheritance, access modifiers and the `AccessorTrait`
hosted only on the root class.

This is roughly 3.75 times slower than the implementation that uses the same functionality with a physical implementation.

In all benchmarks, memory consumption was neglectable. It should be obvious that classes using physical getters and setters use up more memory.


## 6 . Conclusion
Reducing the physical visibility of getters and setters may have the effect that developers fall back to the ubiquitous language
of the project and a more domain specific vocabulary when defining methods, instead of placing such methods in facades
operating on setters and getters of entities. When reducing the relevance of accessors, developers could be encouraged to
 work more closely with the inherent responsibility of an entity, instead of interfacing its properties.

With the the benchmarks executed for the various testcases, it shows that physical existing code has runtime benefits, but
impacts memory consumption, conversely to the implementation that only uses magic methods. Although the memory consumption
for the given benchmarks are neglectable, all and in special regard physical implementation benefit from the
[**opcode cache**](https://www.php.net/manual/en/intro.opcache.php), whereas the logic evaluated with `__call` and the
virtual `getters` and `setters` cannot be cached in the same way the physical existing `getters` and `setters` are.
A codebase that requires such getters and setters, but where those accessors are not frequently used, the system will
benefit from lower memory consumption.

With regards to particular caching mechanisms, it should be easy to provide builds of the code that uses an `AccessorTrait`,
resulting in classes that physically provide getters and setters, if necessary.


---------------------------------------
##### Resources
- [`AccessorTrait` implementation, tests and benchmarks](https://github.com/quant-php/quant)
- [`AccessorTrait` Benchmark implementation](https://github.com/quant-php/core/tree/main/Tests/Benchmarks)
- [`AccessorTrait` documentation](https://quant-php.dev/docs/packages/quant/core)
- [PHP RFC: Access Scope from Magic Accessors](https://wiki.php.net/rfc/access_scope_from_magic_accessors)
- [Basic accessors implementation (WIP)](https://github.com/php/php-src/pull/6873)
- [PHP RFC: Property Accessors](https://wiki.php.net/rfc/property_accessors)