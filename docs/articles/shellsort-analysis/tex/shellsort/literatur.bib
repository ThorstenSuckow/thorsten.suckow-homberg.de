@inproceedings{Pra72,
  title={Shellsort and Sorting Networks},
  author={Vaughan R. Pratt},
  booktitle={Outstanding Dissertations in the Computer Sciences},
  year={1972},
  url={https://api.semanticscholar.org/CorpusID:11928873}
}

@article{PS65,
  title={A method of information sorting in computer memories},
  author={Papernov, AA and Stasevich, GV},
  journal={Problemy Peredachi Informatsii},
  volume={1},
  number={3},
  pages={81--98},
  year={1965},
  publisher={Russian Academy of Sciences, Branch of Informatics, Computer Equipment and~…}
}

@article{She59,
  author = {Shell, D. L.},
  title = {A High-Speed Sorting Procedure},
  year = {1959},
  issue_date = {July 1959},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {2},
  number = {7},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/368370.368387},
  doi = {10.1145/368370.368387},
  journal = {Commun. ACM},
  month = {jul},
  pages = {30–32},
  numpages = {3}
}

@Inbook{GD18a,
  author="G{\"u}ting, Ralf Hartmut
and Dieker, Stefan",
  title="Einf{\"u}hrung",
  bookTitle="Datenstrukturen und Algorithmen",
  year="2018",
  publisher="Springer Fachmedien Wiesbaden",
  address="Wiesbaden",
  pages="1--38",
  abstract="Algorithmen und Datenstrukturen sind Thema dieses Buches. Algorithmen arbeiten auf Datenstrukturen und Datenstrukturen enthalten Algorithmen als Komponenten; insofern sind beide untrennbar miteinander verkn{\"u}pft. In der Einleitung wollen wir diese Begriffe etwas beleuchten und sie einordnen in eine ``Umgebung'' eng damit zusammenh{\"a}ngender Konzepte wie Funktion, Prozedur, Abstrakter Datentyp, Datentyp, Algebra, Typ (in einer Programmiersprache), Klasse und Modul.",
  isbn="978-3-658-04676-7",
  doi="10.1007/978-3-658-04676-7_1",
  url="https://doi.org/10.1007/978-3-658-04676-7_1"
}

@Inbook{GD18c,
  author="G{\"u}ting, Ralf Hartmut
and Dieker, Stefan",
  title="Grundlegende Datentypen",
  bookTitle="Datenstrukturen und Algorithmen",
  year="2018",
  publisher="Springer Fachmedien Wiesbaden",
  address="Wiesbaden",
  pages="63--107",
  abstract="In diesem Kapitel f{\"u}hren wir einige elementare Datentypen ein, die Bausteine f{\"u}r die Implementierung komplexer Algorithmen und Datenstrukturen bilden, n{\"a}mlich Listen, Stacks, Queues, Abbildungen und B{\"a}ume. F{\"u}r Listen werden beispielhaft zwei verschiedene Modelle (Algebren) definiert. Die erste Algebra ist einfach und bietet die Grundoperationen an. Die zweite Algebra ist komplexer, da explizit Positionen in einer Liste verwaltet werden, entspricht daf{\"u}r aber eher der {\"u}blichen Benutzung von Listen in einer imperativen oder objektorientierten Programmiersprache.",
  isbn="978-3-658-04676-7",
  doi="10.1007/978-3-658-04676-7_3",
  url="https://doi.org/10.1007/978-3-658-04676-7_3"
}



@Inbook{GD18e,
  author="G{\"u}ting, Ralf Hartmut and Dieker, Stefan",
  title="Sortieralgorithmen",
  bookTitle="Datenstrukturen und Algorithmen",
  year="2018",
  publisher="Springer Fachmedien Wiesbaden",
  address="Wiesbaden",
  pages="169--200",
  abstract="Das Sortieren einer Menge von Werten {\"u}ber einem geordneten Wertebereich (z. B. int, real, string), das hei{\ss}t, die Berechnung einer geordneten Folge aus einer ungeordneten Folge dieser Werte, ist ein zentrales und intensiv studiertes algorithmisches Problem. Sortieralgorithmen haben viele direkte Anwendungen in der Praxis, finden aber auch h{\"a}ufig Einsatz als Teilschritte in Algorithmen, die ganz andere Probleme l{\"o}sen. Zum Beispiel f{\"u}r die Plane-Sweep- und Divide-and-Conquer-Algorithmen in Kapitel 8 ist Sortieren eine wesentliche Voraussetzung.",
  isbn="978-3-658-04676-7",
  doi="10.1007/978-3-658-04676-7_5",
  url="https://doi.org/10.1007/978-3-658-04676-7_5"
}


@Inbook{OW17a,
  author="Ottmann, Thomas
and Widmayer, Peter",
  title="Grundlagen",
  bookTitle="Algorithmen und Datenstrukturen",
  year="2017",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="1--78",
  abstract="In der Informatik unterscheidet man {\"u}blicherweise zwischen Verfahren zur L{\"o}sung von Problemen und ihrer Implementation in einer bestimmten Programmiersprache auf bestimmten Rechnern. Man nennt die Verfahren Algorithmen. Sie sind das zentrale Thema der Informatik.",
  isbn="978-3-662-55650-4",
  doi="10.1007/978-3-662-55650-4_1",
  url="https://doi.org/10.1007/978-3-662-55650-4_1"
}

@Inbook{OW17b,
  author="Ottmann, Thomas
and Widmayer, Peter",
  title="Sortieren",
  bookTitle="Algorithmen und Datenstrukturen",
  year="2017",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="79--165",
  abstract="Untersuchungen von Computerherstellern und -nutzern zeigen seit vielen Jahren, dass mehr als ein Viertel der kommerziell verbrauchten Rechenzeit auf Sortiervorg{\"a}nge entf{\"a}llt. Es ist daher nicht erstaunlich, dass gro{\ss}e Anstrengungen unternommen wurden m{\"o}glichst effiziente Verfahren zum Sortieren von Daten mithilfe von Computern zu entwickeln. Das gesammelte Wissen {\"u}ber Sortierverfahren f{\"u}llt inzwischen B{\"a}nde.",
  isbn="978-3-662-55650-4",
  doi="10.1007/978-3-662-55650-4_2",
  url="https://doi.org/10.1007/978-3-662-55650-4_2"
}

@Inbook{OW17c,
  author="Ottmann, Thomas and Widmayer, Peter",
  title="Suchen",
  bookTitle="Algorithmen und Datenstrukturen",
  year="2017",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="167--189",
  abstract="Das Suchen in Datenmengen ist eine der wichtigsten und grundlegendsten Operationen, die man mit Computern ausf{\"u}hren k{\"o}nnen m{\"o}chte. Man denke an das Suchen nach einem Stichwort in einem W{\"o}rterbuch oder einer Enzyklop{\"a}die, die Suche nach einer Telefonnummer in einem Telefonverzeichnis, nach einem Namen in einer Symboltabelle, nach einer Kontonummer, Personalnummer, usw. Wir setzen in diesem Kapitel durchweg voraus, dass die Information, nach der wir suchen, durch einen Schl{\"u}ssel eindeutig identifizierbar ist.",
  isbn="978-3-662-55650-4",
  doi="10.1007/978-3-662-55650-4_3",
  url="https://doi.org/10.1007/978-3-662-55650-4_3"
}

@book{Blo17,
  title={Effective Java, 3rd Edition},
  author={Bloch, Joshua},
  year={2017},
  publisher={Addison-Wesley Professional},
  isbn={978-0134686097}
}

@book{HW01,
  editor = {Hoffman, Daniel M. and Weiss, David M.},
  title = {Software fundamentals: collected papers by David L. Parnas},
  year = {2001},
  isbn = {0201703696},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address = {USA}
}

@book{Mar03,
  author = {Martin, Robert Cecil},
  title = {Agile Software Development: Principles, Patterns, and Practices},
  year = {2003},
  isbn = {0135974445},
  publisher = {Prentice Hall PTR},
  address = {USA},
  abstract = {From the Publisher: Best selling author and world-renowned software development expert Robert C. Martin shows how to solve the most challenging problems facing software developers, project managers, and software project leaders today. This comprehensive, pragmatic tutorial on Agile Development and eXtreme programming, written by one of the founding father of Agile Development: Teaches software developers and project managers how to get projects done on time, and on budget using the power of Agile Development. Uses real-world case studies to show how to of plan, test, refactor, and pair program using eXtreme programming. Contains a wealth of reusable C++ and Java code. Focuses on solving customer oriented systems problems using UML and Design Patterns. Robert C. Martin is President of Object Mentor Inc. Martin and his team of software consultants use Object-Oriented Design, Patterns, UML, Agile Methodologies, and eXtreme Programming with worldwide clients. He is the author of the best-selling book Designing Object-Oriented C++ Applications Using the Booch Method (Prentice Hall, 1995), Chief Editor of, Pattern Languages of Program Design 3 (Addison Wesley, 1997), Editor of, More C++ Gems (Cambridge, 1999), and co-author of XP in Practice, with James Newkirk (Addison-Wesley, 2001). He was Editor in Chief of the C++ Report from 1996 to 1999. He is a featured speaker at international conferences and trade shows. Author Biography: ROBERT C. MARTIN is President of Object Mentor Inc. Martin and his team of software consultants use Object-Oriented Design, Patterns, UML, Agile Methodologies, and eXtreme Programming with worldwide clients. He is the author of the best-selling book Designing Object-Oriented C++ Applications Using the Booch Method (Prentice Hall, 1995), Chief Editor of, Pattern Languages of Program Design 3 (Addison Wesley, 1997), Editor of, More C++ Gems (Cambridge, 1999), and co-author of XP in Practice, with James Newkirk (Addison-Wesley, 2001). He was Editor in Chief of the C++ Report from 1996 to 1999. He is a featured speaker at international conferences and trade shows.}
}


@book{Mar08,
  author = {Martin, Robert C.},
  title = {Clean Code: A Handbook of Agile Software Craftsmanship},
  year = {2008},
  isbn = {0132350882},
  publisher = {Prentice Hall PTR},
  address = {USA},
  edition = {1},
  abstract = {Even bad code can function. But if code isnt clean, it can bring a development organization to its knees. Every year, countless hours and significant resources are lost because of poorly written code. But it doesnt have to be that way.Noted software expert Robert C. Martin, presents a revolutionary paradigm with Clean Code: A Handbook of Agile Software Craftsmanship. Martin, who has helped bring agile principles from a practitioners point of view to tens of thousands of programmers, has teamed up with his colleagues from Object Mentor to distill their best agile practice of cleaning code on the fly into a book that will instill within you the values of software craftsman, and make you a better programmerbut only if you work at it.What kind of work will you be doing? Youll be reading codelots of code. And you will be challenged to think about whats right about that code, and whats wrong with it. More importantly you will be challenged to reassess your professional values and your commitment to your craft. Clean Code is divided into three parts. The first describes the principles, patterns, and practices of writing clean code. The second part consists of several case studies of increasing complexity. Each case study is an exercise in cleaning up codeof transforming a code base that has some problems into one that is sound and efficient. The third part is the payoff: a single chapter containing a list of heuristics and smells gathered while creating the case studies. The result is a knowledge base that describes the way we think when we write, read, and clean code.Readers will come away from this book understandingHow to tell the difference between good and bad codeHow to write good code and how to transform bad code into good codeHow to create good names, good functions, good objects, and good classesHow to format code for maximum readability How to implement complete error handling without obscuring code logicHow to unit test and practice test-driven developmentWhat smells and heuristics can help you identify bad codeThis book is a must for any developer, software engineer, project manager, team lead, or systems analyst with an interest in producing better code.}
}




@inproceedings{PW76,
  author = {Parnas, D. L. and W\"{u}rges, H.},
  title = {Response to undesired events in software systems},
  year = {1976},
  publisher = {IEEE Computer Society Press},
  address = {Washington, DC, USA},
  abstract = {This paper discusses an approach to handling run-time errors in software systems. It is often assumed that in programs which can be proven correct, errors will not be a problem. This paper is predicted on the assumption that, even with correct programs, undesired events at run-time will continue to be a problem. Routines to respond to these undesired events (UEs) must be provided in reliable systems.This paper describes a program organization which aims at satisfying the following criteria:(1) UE response routines are written by each programmer in terms of the abstract machine which he uses for his normal case code. UEs are reported in those terms. He is never forced to use information about the implementation of other modules in the system.(2) Programs can be written so that the code for UE detection, UE correction, and normal case, are lexically separate and can be modified independently.(3) The system can evolve from an initial version that does little recovery to one which uses sophisticated recovery techniques without a change in the structure of the system.(4) Even with unsophisticated recovery procedures, the task of locating the module containing a bug discovered at run-time does not require internal knowledge of many modules.(5) Costs incurred because of the recovery techniques are low as no UE occurs.},
  booktitle = {Proceedings of the 2nd International Conference on Software Engineering},
  pages = {437–446},
  numpages = {10},
  keywords = {Run-time errors, Reliable systems, Information hiding, Error recovery, “Uses”-hierarchy},
  location = {San Francisco, California, USA},
  series = {ICSE '76}
}



@Inbook{OW17e,
  author="Ottmann, Thomas
and Widmayer, Peter",
  title="B{\"a}ume",
  bookTitle="Algorithmen und Datenstrukturen",
  year="2017",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="259--402",
  abstract="B{\"a}ume geh{\"o}ren zu den wichtigsten in der Informatik auftretenden Datenstrukturen. Entscheidungsb{\"a}ume, Syntaxb{\"a}ume, Ableitungsb{\"a}ume, Kodeb{\"a}ume, spannende B{\"a}ume, baumartig strukturierte Suchr{\"a}ume, Suchb{\"a}ume und viele andere belegen die Allgegenwart von B{\"a}umen. Wir haben in den vorangehenden Kapiteln bereits mehrfach B{\"a}ume als intuitives Konzept benutzt, so z. B. zur Erl{\"a}uterung des Sortierverfahrens Heapsort in Abschnitt 2.3, beim Nachweis unterer Schranken f{\"u}r das Sortierproblem in Abschnitt 2.8 und beim Bin{\"a}rbaum-Sondieren in Abschnitt 4.3.4.",
  isbn="978-3-662-55650-4",
  doi="10.1007/978-3-662-55650-4_5",
  url="https://doi.org/10.1007/978-3-662-55650-4_5"
}

@Inbook{OW17d,
  author="Ottmann, Thomas and Widmayer, Peter",
  title="Hashverfahren",
  bookTitle="Algorithmen und Datenstrukturen",
  year="2017",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="191--258",
  abstract="In den Kapiteln 1 und 3 haben wir einige Methoden kennen gelernt, die es erlauben eine Menge von Datens{\"a}tzen so zu speichern, dass die Operationen Suchen, Einf{\"u}gen und Entfernen unterst{\"u}tzt werden. Jeder Datensatz ist dabei gekennzeichnet durch einen eindeutigen Schl{\"u}ssel. Zu jedem Zeitpunkt ist lediglich eine (kleine) Teilmenge K aller m{\"o}glichen Schl{\"u}ssel {\$}{\$} {\{}{\backslash}mathcal{\{}K{\}}{\}} {\$}{\$}(englisch: keys) gespeichert.",
  isbn="978-3-662-55650-4",
  doi="10.1007/978-3-662-55650-4_4",
  url="https://doi.org/10.1007/978-3-662-55650-4_4"
}

@BOOK{CL22,
  title     = "Introduction to Algorithms, fourth edition",
  author    = "Cormen, Thomas H and Leiserson, Charles E",
  publisher = "MIT Press",
  month     =  apr,
  year      =  2022,
  address   = "London, England",
  language  = "en",
  isbn      = {9780262046305}
}

@unpublished{Dij81,
author = "Edsger W. Dijkstra",
title = "Smoothsort, an alternative for sorting in situ",
month = aug,
year = "1981",
note = "circulated privately",
url = "http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD796a.PDF"
}

@book{Knu97b,
  author = {Knuth, Donald E.},
  title = {The Art of Computer Programming, Volume 3 (2nd Ed.): Sorting and Searching},
  year = {1997},
  isbn = {0201896850},
  publisher = {Addison Wesley Longman Publishing Co., Inc.},
  address = {USA}
}

@article{CBM89,
  title = {Efficient reconstruction of binary trees from their traversals},
  journal = {Applied Mathematics Letters},
  volume = {2},
  number = {1},
  pages = {79-82},
  year = {1989},
  issn = {0893-9659},
  doi = {https://doi.org/10.1016/0893-9659(89)90122-5},
  url = {https://www.sciencedirect.com/science/article/pii/0893965989901225},
  author = {R.D. Cameron and B.K. Bhattacharya and E.A.T. Merks},
  abstract = {Given the n nodes of a binary tree in both inorder and preorder sequence, the tree can be uniquely identified. An efficient algorithm for reconstructing such trees from their sequences is presented, using O (n) time and O (h) intermediate storage, where h is the height of the tree being reconstructed.}
}

@book{Hof22,
  place={München},
  isbn = {978-3446470293},
  title={Theoretische Informatik},
  publisher={Carl Hanser Verlag},
  author={Hoffmann, Dirk W.},
  year={2022}}

@book{Ull23,
  title={Java ist auch eine Insel: Das umfassende Handbuch, 17. Auflage},
  author={Ullenboom, Christian},
  publisher={Galileo Computing},
  isbn={978-3-8362-9544-4},
  year={2023}
}


@article{CK75,
  title = {Depth of Recursion and the Ackermann Function},
  author = {Cornelius, B. J. and Kirby, G. H.},
  year = {1975},
  month = jun,
  journal = {BIT Numerical Mathematics},
  volume = {15},
  number = {2},
  pages = {144--150},
  issn = {1572-9125},
  doi = {10.1007/BF01932687},
  abstract = {The maximum depth of recursion refers to the number of levels of activation of a procedure which exist during the deepest call of the procedure. A re-examination of the maximum depth of recursion of the Ackermann function results in a new formula which takes a full account of the dependence of this property on the parameters. It is shown that the recursive use parameter of the Ackermann function contributes to the depth of recursion, and that this contribution may be reduced by rearranging the order of the parameters. The stack required by the Ackermann function was investigated using ALGOL 68-R.}
}

@book{SW11,
  added-at = {2012-11-06T00:00:00.000+0100},
  author = {Sedgewick, Robert and Wayne, Kevin},
  biburl = {https://www.bibsonomy.org/bibtex/22fde79ee322687a901feb1b1823bb447/dblp},
  interhash = {552396c14a0129abbe40ca305b4f001b},
  intrahash = {2fde79ee322687a901feb1b1823bb447},
  isbn = {978-0-321-57351-3},
  keywords = {dblp},
  pages = {I-XII, 1-955},
  publisher = {Addison-Wesley},
  timestamp = {2012-11-07T11:41:50.000+0100},
  title = {Algorithms, 4th Edition.},
  year = 2011
}


@Inbook{GD18b,
  author="G{\"u}ting, Ralf Hartmut
and Dieker, Stefan",
  title="Programmiersprachliche Konzepte f{\"u}r Datenstrukturen",
  bookTitle="Datenstrukturen und Algorithmen",
  year="2018",
  publisher="Springer Fachmedien Wiesbaden",
  address="Wiesbaden",
  pages="39--61",
  abstract="Im ersten Kapitel haben wir gesagt, dass wir unter einer Datenstruktur die Implementierung eines Datentyps auf algorithmischer Ebene verstehen wollen. Die Implementierung st{\"u}tzt sich letztendlich ab auf Primitive, die von einer Programmiersprache zur Verf{\"u}gung gestellt werden. Diese Primitive sind wiederum Datentypen, eben die Typen der Programmiersprache.",
  isbn="978-3-658-04676-7",
  doi="10.1007/978-3-658-04676-7_2",
  url="https://doi.org/10.1007/978-3-658-04676-7_2"
}

@article{Flo64,
  author = {Floyd, Robert W.},
  title = {Algorithm 245: Treesort},
  year = {1964},
  issue_date = {Dec. 1964},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {7},
  number = {12},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/355588.365103},
  doi = {10.1145/355588.365103},
  journal = {Commun. ACM},
  month = {dec},
  pages = {701},
  numpages = {2}
}

@Inbook{GD18d,
  author="G{\"u}ting, Ralf Hartmut
and Dieker, Stefan",
  title="Datentypen zur Darstellung von Mengen",
  bookTitle="Datenstrukturen und Algorithmen",
  year="2018",
  publisher="Springer Fachmedien Wiesbaden",
  address="Wiesbaden",
  pages="109--167",
  abstract="Die Darstellung von Mengen ist offensichtlich eine der grundlegendsten Aufgaben {\"u}berhaupt. Wir haben im letzten Kapitel bereits einige Bausteine kennengelernt, die zur Darstellung von Mengen eingesetzt werden k{\"o}nnen (Listen, B{\"a}ume). In diesem Kapitel werden verschiedene Datentypen f{\"u}r Mengen betrachtet, die sich durch ihre Operationss{\"a}tze unterscheiden; es geht nun darum, die Grundbausteine geeignet auszuw{\"a}hlen und zu verfeinern, um spezielle Operationen effizient zu unterst{\"u}tzen.",
  isbn="978-3-658-04676-7",
  doi="10.1007/978-3-658-04676-7_4",
  url="https://doi.org/10.1007/978-3-658-04676-7_4"
}


@BOOK{Oes05,
  title     = "Analyse und Design mit UML 2",
  author    = "Oestereich, Bernd",
  publisher = "Oldenbourg Wissenschaftsverlag GmbH",
  year      =  2005,
  isbn      = {3486576542},
}
